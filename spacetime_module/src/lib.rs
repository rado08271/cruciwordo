use spacetimedb::{table, reducer, Table, ReducerContext, Identity, Timestamp};
use generator::{generate_board_with_dictionary, id};

#[table(name = word, public)]
pub struct WordPlacementsDatabaseModel {
    #[primary_key]
    pub id: String,
    pub board_id: String,
    pub direction: String,
    pub start_row: u8,
    pub start_col: u8,
    pub word: String,
}

#[table(name = board, public)]
pub struct BoardDatabaseModel {
    #[primary_key]
    pub id: String,
    pub created_date: Timestamp,
    pub created_by: Identity,
    pub rows: u8,
    pub cols: u8,
    pub message: String,
    pub solution: String,
    pub grid: String,
}

#[table(name = game_session, public, index(name = board_id_played_by, btree(columns = [board_id, played_by])))]
pub struct GameSessionDatabaseModel {
    #[primary_key]
    pub id: String,
    pub board_id: String,
    pub started_date: Timestamp,
    pub played_by: Identity,
    pub finished: bool,
    pub is_online: bool,
    pub found_words: String
}

#[table(name = dictionary, private)]
pub struct DictionaryDatabaseModel {
    #[primary_key]
    pub word: String,
    pub language: String,
    pub category: Option<String>
}

fn validate_board_params(rows: u8, cols: u8) -> Result<(), String> {
    if rows > 5 && cols > 5 {
        Ok(())
    } else {
        Err("Grid size needs to be at least 5x5".to_string())
    }
}

#[reducer]
pub fn generate_new_board(reducer_context: &ReducerContext, rows: u8, cols: u8, message: String) -> Result<(), String> {
    let valid_params = validate_board_params(rows, cols);

    if valid_params.is_err() {
        return Err(valid_params.unwrap_err())
    }

    let number_rng = reducer_context.rng();

    let words = reducer_context.db.dictionary().iter();
    let words_dictionary: Vec<String> = words.map(|w|w.word).collect::<Vec<String>>();

    // This is called from the module
    let (generated_board, placements) = generate_board_with_dictionary(rows as usize, cols as usize, message.clone(), &words_dictionary, number_rng);

    // Board id generated by custom nanoid ensures id is easier to remeber and read
    let board_id = id!(10, number_rng);

    // Reduce 2 dimensional array into a string
    let grid_string: String = generated_board.grid.iter()
        .map(|r| r.iter().map(|c| format!("{}", c)).collect::<String>())
        .rfold(String::from(""), |data, r| format!("{}{}", r, data));

    let board_model = BoardDatabaseModel {
        id: board_id.clone(),
        created_date: reducer_context.timestamp,
        created_by: reducer_context.sender,
        solution: generated_board.solution,
        grid: grid_string,
        message: message, cols: cols, rows: rows
    };

    let words_placement_model: Vec<WordPlacementsDatabaseModel> = placements.iter().map(| placement | WordPlacementsDatabaseModel {
        id: format!("{}-{}", board_id.clone(), &placement.word),
        start_row: placement.row as u8,
        start_col: placement.col as u8,
        word: placement.word.clone(),
        direction: placement.direction.to_string(),
        board_id: board_id.clone(),
    }).collect();

    reducer_context.db.board().insert(board_model);

    for placement_model in words_placement_model {
        reducer_context.db.word().insert(placement_model);
    }

    return Ok(());
}

// #[reducer]
pub fn join_game(reducer_context: &ReducerContext, board_id: String) -> Result<(), String> {
    let board_id_played_by_index: spacetimedb::RangedIndex<_, (String, Identity), _> = reducer_context.db.game_session().board_id_played_by();

    // Receive iterator with our results
    let games_iterator = board_id_played_by_index.filter((board_id.as_str(), reducer_context.sender));

    // Check if game already exists if not we should create a game
    if games_iterator.count() == 0 {
        let initial_game_session_model = GameSessionDatabaseModel {
            id: format!("{}-{}", board_id.clone(), reducer_context.sender.to_string()),
            board_id: board_id.clone(),
            started_date: reducer_context.timestamp,
            played_by: reducer_context.sender,
            finished: false,
            is_online: true,
            found_words: String::from(""),
        };

        reducer_context.db.game_session().insert(initial_game_session_model);
    }

    return Ok(())
}

// #[reducer]
// pub fn set_game_finished(reducer_context: &ReducerContext, game_id: String) -> Result<(), String> {
//     if let Some(game) = reducer_context.db.game().id().find(game_id.clone()) {
//         reducer_context.db.game().id().update(GameDatabaseModel {
//             finished: true,
//             ..game
//         });
//         return Ok(())
//     } else {
//         return Err(format!("The game with id '{}' was not found!", game_id).clone());
//     }
// }

#[reducer]
pub fn save_word(reducer_context: &ReducerContext, word: String) -> Result<(), String> {
    let dictionary_word = DictionaryDatabaseModel {
        word: word, language: "en".to_string(), category: None
    };
    reducer_context.db.dictionary().insert(dictionary_word);

    Ok(())
}

