use std::fmt::format;
use log::log;
use spacetimedb::{table, reducer, Table, ReducerContext, Identity, Timestamp, StdbRng};
use spacetimedb::rand::Rng;
use generator::{generate_board, generate_board_with_dictionary, id};

#[table(name = board, public)]
pub struct BoardDatabaseModel {
    #[primary_key]
    pub id: String,
    pub created_date: Timestamp,
    pub created_by: Identity,
    pub rows: u64,
    pub cols: u64,
    pub message: String,
    pub solution: String,
    pub grid: String,
    pub words: String
}

#[table(name = game, public, index(name = board_id_played_by, btree(columns = [board_id, played_by])))]
pub struct GameDatabaseModel {
    #[primary_key]
    pub id: String,
    pub board_id: String,
    pub started_date: Timestamp,
    pub played_by: Identity,
    pub finished: bool
}

#[table(name = dictionary, public)]
pub struct DictionaryDatabaseModel {
    #[primary_key]
    pub word: String,
    pub language: String,
    pub category: Option<String>
}


fn validate_board_params(rows: u64, cols: u64) -> Result<(), String> {
    if rows > 5 && cols > 5 {
        Ok(())
    } else {
        Err("Grid size needs to be at least 5x5".to_string())
    }
}

#[reducer]
pub fn generate_new_board(reducer_context: &ReducerContext, rows: u64, cols: u64, message: String) -> Result<(), String> {
    let valid_params = validate_board_params(rows, cols);

    if valid_params.is_err() {
        return Err(valid_params.unwrap_err())
    }

    let mut number_rng = reducer_context.rng();

    let words = reducer_context.db.dictionary().iter();
    let words_dictionary: Vec<String> = words.map(|w|w.word).collect::<Vec<String>>();

    // This is called from the application
    let generated_board = generate_board_with_dictionary(rows as usize, cols as usize, message.clone(), &words_dictionary, number_rng);
    // let generated_board = generate_board(rows as usize, cols as usize, message.clone());

    // Board id generated by custom nanoid ensures id is easier to remeber and read
    let board_id = id!(10, number_rng);

    // Reduce 2 dimensional array into a string
    let grid_string: String = generated_board.grid.iter()
        .map(|r| r.iter().map(|c| format!("{}", c)).collect::<String>())
        .rfold(String::from(""), |data, r| format!("{}{}", r, data));

    // Reduce words array to string delimited by |
    let mut words_string: String = String::new();
    for word in generated_board.words {
        words_string = format!("{}|{}", words_string, word)
    }

    let board_model = BoardDatabaseModel {
        id: board_id.clone(),
        created_date: reducer_context.timestamp,
        created_by: reducer_context.sender,
        solution: generated_board.solution,
        grid: grid_string,
        words: words_string,
        message: message, cols: cols as u64, rows: rows as u64
    };

    reducer_context.db.board().insert(board_model);

    // return Ok(board_id.clone());
    return Ok(());
}

#[reducer]
pub fn start_game(reducer_context: &ReducerContext, board_id: String) -> Result<(), String> {
    let board_id_played_by_index: spacetimedb::RangedIndex<_, (String, Identity), _> = reducer_context.db.game().board_id_played_by();

    // Receive iterator with our results
    let games_iterator = reducer_context.db.game().board_id_played_by().filter((board_id.as_str(), reducer_context.sender));

    // Check if game already exists if not we should create a game
    if games_iterator.count() > 0 {
        let game_model = GameDatabaseModel {
            id: format!("{}-{}", board_id.clone(), reducer_context.sender.to_string()),
            board_id: board_id.clone(),
            started_date: reducer_context.timestamp,
            played_by: reducer_context.sender,
            finished: false,
        };

        reducer_context.db.game().insert(game_model);
    }

    return Ok(())
}

#[reducer]
pub fn set_game_finished(reducer_context: &ReducerContext, game_id: String) -> Result<(), String> {
    if let Some(game) = reducer_context.db.game().id().find(game_id.clone()) {
        reducer_context.db.game().id().update(GameDatabaseModel {
            finished: true,
            ..game
        });
        return Ok(())
    } else {
        return Err(format!("The game with id '{}' was not found!", game_id).clone());
    }
}

#[reducer]
pub fn save_word(reducer_context: &ReducerContext, word: String) -> Result<(), String> {
    let dictionary_word = DictionaryDatabaseModel {
        word: word, language: "en".to_string(), category: None
    };
    reducer_context.db.dictionary().insert(dictionary_word);

    Ok(())
}

